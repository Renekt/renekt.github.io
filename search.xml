<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM</title>
      <link href="/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8F%8A%E8%B0%83%E4%BC%98/"/>
      <url>/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8F%8A%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h3 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h3><ul><li>启动。启动一个java程序时，一个JVM实例就产生了，任何一个拥有<code>public static void main(String[] args)</code>函数的class都可以作为JVM实例运行的起点。</li><li>运行。<code>main()</code>作为该程序初始线程的起点，任何其他线程均由该线程启动。</li><li>消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者<code>System.exit()</code>来退出。</li></ul><a id="more"></a><p>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。程序开始执行时他才运行，程序结束时他就停止。在同一台机器上运行三个程序，就会有三个运行中的Java虚拟机。 Java虚拟机总是开始于一个main()方法，这个方法必须是公有、返回void、只接受一个字符串数组。在程序执行时，你必须给Java虚拟机指明这个包换main()方法的类名。main()方法是程序的起点，他被执行的线程初始化为程序的初始线程。程序中其他的线程都由他来启动。</p><p>Java中的线程分为两种：守护线程 （daemon）和普通线程（non-daemon）。守护线程是Java虚拟机自己使用的线程，比如负责垃圾收集的线程就是一个守护线程。当然，你也可以把自己的程序设置为守护线程。包含main()方法的初始线程不是守护线程。</p><p>只要Java虚拟机中还有普通的线程在执行，Java虚拟机就不会停止。如果有足够的权限，你可以调用exit()方法终止程序。</p><h3 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h3><ul><li>类加载器（ClassLoader）（用来装载.class文件）</li><li>执行引擎（执行字节码，或者执行本地方法）</li><li>运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈）</li></ul><h3 id="Java运行时数据区"><a href="#Java运行时数据区" class="headerlink" title="Java运行时数据区"></a>Java运行时数据区</h3><p><img src="../assets/1178695-20170628165401477-790456271.png" alt="img"></p><h4 id="1-Java堆（heap）"><a href="#1-Java堆（heap）" class="headerlink" title="1. Java堆（heap）"></a>1. Java堆（heap）</h4><ul><li><p><font color="red">被所有线程共享的一块内存区域，在虚拟机启动时创建；</font></p></li><li><p>用来<strong>存储对象实例</strong>,几乎所有的对象实例都是在这里分配内存；</p></li><li><p>可以通过-<code>Xmx</code>和-<code>Xms</code>控制堆的大小；</p></li><li><p>该区域会抛出的异常：</p><ul><li><code>OutOfMemoryError</code>：当在堆中没有内存完成实例分配，且堆也无法再扩展时。</li></ul></li><li><p>Java堆是垃圾收集器管理的主要区域。</p></li><li><p>Java堆还可以细分为：新生代（New/Young）、旧生代/年老代（Old/Tenured）。</p><ul><li><strong>新生代：</strong>新建的对象都由新生代分配内存。常常又被划分为<code>Eden</code>区和<code>Survivor</code>区。<code>Eden</code>空间不足时会把存活的对象转移到<code>Survivor</code>。新生代的大小可由<code>-Xmn</code>控制，也可用<code>-XX:SurvivorRatio</code>控制<code>Eden</code>和<code>Survivor</code>的比例。</li><li><strong>老年代：</strong>存放经过多次垃圾回收仍然存活的对象。</li></ul><blockquote><p>注意：线程共享的Java堆中可以划分出多个线程私有的分配缓存区（Thread Local Allocation Buffer,TLAB）。</p></blockquote></li></ul><h4 id="2-方法区"><a href="#2-方法区" class="headerlink" title="2. 方法区"></a>2. 方法区</h4><ul><li><p><font color="red">与Java堆一样，是各个线程共享的内存区域；</font></p></li><li><p>用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></p></li><li><p>该区域会抛出的异常：</p><ul><li><code>OutOfMemoryError</code>：当方法区无法满足内存的分配需求</li></ul></li><li><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如同永久代的名字一样”永久“存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收”成绩“比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。</p><blockquote><p>注意：</p><p>对于习惯在<code>HotSpot</code>虚拟机上开发、部署程序的开发者来说，很多人更愿意把方法区成为”<strong>永久代</strong>“，事实上两者并不等价，仅仅是因为HotSpot虚拟机选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省区专门为方法区编写内存管理代码的工作，对于其他虚拟机来说，是不存在永久代的概念的。并且，使用永久代来实现方法区，并不是一个好主意，因为这样更容易遇到内存溢出的问题。（永久代有-XX:MaxPermSize的上限）。<font color="red">JDK1.8的HotSpot已经将永久代移除。</font></p></blockquote></li></ul><h4 id="3-运行时常量池"><a href="#3-运行时常量池" class="headerlink" title="3.运行时常量池"></a>3.运行时常量池</h4><ul><li><font color="red">方法区的一部分</font></li><li>用于存<strong>放编译期生成的各种字面量与符号引用</strong>，如String类型常量就存放在常量池</li><li>该区域会抛出的异常：<ul><li><code>OutOfMemoryError</code>异常：当常量池无法再申请到内存时</li></ul></li></ul><h4 id="4-Java虚拟机栈帧（VM-Stack）"><a href="#4-Java虚拟机栈帧（VM-Stack）" class="headerlink" title="4. Java虚拟机栈帧（VM Stack）"></a>4. Java虚拟机栈帧（VM Stack）</h4><ul><li><font color="red"><strong>线程私有，生命周期与线程相同</strong></font></li><li>存储方法的局部变量表、操作数栈、动态链接、方法出口等信息。<ul><li>局部变量表存放了编译期可知的各种几本数据类型（boolean,byte,char,short,int,float,long,double）、对象引用（reference类型，它不等同于对象本身，可能是一个只想对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<code>returnAddress</code>类型（指向了一条字节码指令的地址）。</li></ul></li><li>虚拟机栈描述的是Java方法执行的内存模型:每个方法执行的同时都会创建一个栈帧，每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>该区域会抛出两种异常：<ul><li><code>StackOverflowError</code>异常：当线程请求的栈深度大于虚拟机所允许的深度</li><li><code>OutOfMemoryError</code>异常：如果栈的扩展时无法申请到足够的内存</li></ul></li></ul><p>JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部<strong>基本类型</strong>的变量、部分的返回结果以及Stack Frame。其他引用类型的对象在JVM栈上仅存放<strong>变量名</strong>和指向堆上对象实例的<strong>首地址</strong>。</p><h4 id="5-本地方法栈（Native-Method-Stack）"><a href="#5-本地方法栈（Native-Method-Stack）" class="headerlink" title="5. 本地方法栈（Native Method Stack）"></a>5. 本地方法栈（Native Method Stack）</h4><ul><li>与虚拟机栈帧相似，主要为虚拟机使用到的Native方法服务，<font color="red">在HotSpot虚拟机中直接把本地方法栈与虚拟机栈二合一</font></li><li>与虚拟机栈一样，本地方法栈区域也会抛出两种异常：<ul><li><code>StackOverflowError</code></li><li><code>OutofMemoryError</code></li></ul></li></ul><h4 id="6-程序计数器（Program-Counter-Register）"><a href="#6-程序计数器（Program-Counter-Register）" class="headerlink" title="6. 程序计数器（Program Counter Register）"></a>6. 程序计数器（Program Counter Register）</h4><ul><li>当前线程所执行的字节码的行号指示器</li><li>当前线程私有</li><li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>Native</code>方法，这个计数器值则为空（<code>Undefined</code>）.</li><li><font color="red">唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</font></li></ul><h4 id="7-直接内存（Direct-Memory）"><a href="#7-直接内存（Direct-Memory）" class="headerlink" title="7. 直接内存（Direct Memory）"></a>7. 直接内存（Direct Memory）</h4><ul><li><font color="red">直接内存并不是虚拟机运行的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁使用</font></li><li>NIO可以使用Native函数库直接分配堆外内存，堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作</li><li>大小不受Java堆大小的限制，受本机(服务器)内存限制</li><li><code>OutOfMemoryError</code>异常：系统内存不足时</li></ul><p><strong>总结：</strong>Java对象实例存放在堆中；常量存放在方法区的常量池；虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据放在方法区；以上区域是所有线程共享的。栈是线程私有的，存放该方法的局部变量表(基本类型、对象引用)、操作数栈、动态链接、方法出口等信息。</p><p><font color="red"><strong>一个Java程序对应一个JVM，一个方法（线程）对应一个Java栈。</strong></font></p><h3 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h3><p><strong>Java代码的编译和执行包括了三个重要机制：</strong></p><p>（1）Java源码编译机制（<code>.java</code>源代码文件 -&gt;<code>.class</code>字节码文件）</p><p>（2）类加载机制（<code>ClassLoader</code>）</p><p>（3）类执行机制（JVM执行引擎）</p><h4 id="1-Java源码编译机制"><a href="#1-Java源码编译机制" class="headerlink" title="1. Java源码编译机制"></a>1. Java源码编译机制</h4><p>　Java源代码是不能被机器识别的，需要先经过编译器编译成JVM可以执行的.class字节码文件，再由解释器解释运行。即：Java源文件（.java） – Java编译器 –&gt; Java字节码文件 （.class） – Java解释器 –&gt; 执行。流程图如下：<img src="../assets/1178695-20170628214004258-1031896523.png" alt="img"></p><p>字节码文件（.class）是平台无关的。</p><p>Java中字符只以一种形式存在：Unicode。字符转换发生在JVM和OS交界处（Reader/Writer）。</p><p>最后生成的class文件由以下部分组成：</p><ul><li>结构信息。包括class文件格式版本号及各部分的数量与大小的信息</li><li>元数据。对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池</li><li>方法信息。对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</li></ul><h4 id="2-类加载机制（Classloader）"><a href="#2-类加载机制（Classloader）" class="headerlink" title="2. 类加载机制（Classloader）"></a>2. 类加载机制（Classloader）</h4><p>Java程序并不是一个可执行文件，是由多个独立的类文件组成。这些类文件并非一次性全部装入内存，而是依据程序<strong>逐步载入</strong>。</p><p>JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</p><p><img src="../assets/1178695-20170628215753493-689334206.png" alt="img"></p><p>（1）<code>Bootstrap ClassLoader</code></p><ul><li>​    JVM的<strong>根ClassLoader</strong>，由C++实现    </li><li>加载Java的<strong>核心API</strong>：<code>$JAVA_HOME</code>中<code>jre/lib/rt.jar</code>中所有<code>class</code>文件的加载，这个jar中包含了java规范定义的所有接口以及实现。</li><li>JVM启动时即初始化此<code>ClassLoader</code></li></ul><p>（2）<code>Extension ClassLoader</code></p><ul><li>加载Java扩展API（lib/ext中的类）</li></ul><p>（3）<code>App ClassLoader</code></p><ul><li>加载Classpath目录下定义的class</li></ul><p>（4）<code>Custom ClassLoader</code></p><ul><li>属于应用程序根据自身需要自定义的<code>ClassLoader</code>，如tomcat、jboss都会根据J2EE规范自行实现<code>ClassLoader</code></li></ul><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从<code>Custom ClassLoader</code>到<code>BootStrap ClassLoader</code>逐层检查，只要某个<code>classloader</code>已加载就视为已加载此类，保证此类只所有<code>ClassLoader</code>加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p><p><strong>双亲委派机制</strong></p><p>　　JVM在加载类时默认采用的是<strong>双亲委派</strong>机制。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归。如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><p>　　作用：1）避免重复加载；2）更安全。如果不是双亲委派，那么用户在自己的classpath编写了一个java.lang.Object的类，那就无法保证Object的唯一性。所以使用双亲委派，即使自己编写了，但是永远都不会被加载运行。</p><p><strong>破坏双亲委派机制</strong></p><p>　　双亲委派机制并不是一种强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。</p><p>　　<strong>线程上下文类加载器</strong>，这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那么这个类加载器就是应用程序类加载器。像JDBC就是采用了这种方式。这种行为就是逆向使用了加载器，违背了双亲委派模型的一般性原则。</p><h4 id="3-类执行机制"><a href="#3-类执行机制" class="headerlink" title="3.类执行机制"></a>3.类执行机制</h4><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p><p><img src="../assets/1178695-20170628214602586-89886180.png" alt="img"></p><p>JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有<strong>局部变量区和操作数栈</strong>两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。</p><p>主要的执行技术：解释，即时编译，自适应优化、芯片级直接执行</p><ul><li>解释属于第一代JVM，</li><li>即时编译JIT属于第二代JVM，</li><li>自适应优化（目前Sun的HotspotJVM采用这种技术）则吸取第一代JVM和第二代JVM的经验，采用两者结合的方式</li></ul><p>　　开始对所有的代码都采取解释执行的方式，并监视代码执行情况。对那些经常调用的方法启动一个后台线程，将其编译为本地代码，并进行优化。若方法不再频繁使用，则取消编译过的代码，仍对其进行解释执行。</p><h3 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h3><p><strong>GC的基本原理：</strong>将内存中不再被引用的对象进行回收，GC中用于回收的方法称为收集器。垃圾：不再被引用的对象。</p><p>由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停。</p><ul><li>对新生代的对象的收集称为<code>minor GC</code>；</li><li>对老年代的对象的收集称为<code>Full GC</code>；</li><li>程序中主动调用<code>System.gc()</code>的GC为<code>Full GC</code>。</li></ul><p>　　Java垃圾回收是单独的后台线程gc执行的，自动运行无需显示调用。即使主动调用了<code>java.lang.System.gc()</code>，该方法也只会提醒系统进行垃圾回收，但系统不一定会回应，可能会不予理睬。</p><p><strong>判断一块内存空间是否符合回收标准：</strong></p><p>（1）对象赋予了空值，且之后再未调用（<code>obj = null</code>;）</p><p>（2）对象赋予了新值，即重新分配了内存空间（<code>obj = new Obj()</code>;）</p><p><strong>内存泄漏：</strong>程序中保留着对永远不再使用的对象的引用。因此这些对象不回被GC回收，却一直占用内存空间却毫无用处。即：1）对象是可达的；2）对象是无用的。满足这两个条件即可判定为内存泄漏。</p><p>　　应确保不需要的对象不可达，通常采用将对象字段设置为null的方式，或从容器collection中移除对象。局部变量不再使用时无需显示设置为null，因为对局部变量的引用会随着方法的退出而自动清除。</p><p><strong>内存泄露的原因：</strong>1）全局集合；2）缓存；3）ClassLoader</p><p>垃圾回收的两种方法：引用计数、对象引用遍历。</p><p>垃圾回收器的7种选择：</p><h4 id="1-哪些内存需要回收"><a href="#1-哪些内存需要回收" class="headerlink" title="1. 哪些内存需要回收"></a>1. 哪些内存需要回收</h4><p>​    由于程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。</p><p>​    在堆里边存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还”存活“着，哪些已经”死去“。</p><h5 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h5><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>引用计数算法的优点：</p><ul><li>实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法</li></ul><p>缺点：</p><ul><li>很难解决对象之间相互循环引用的问题。这也是为什么主流的Java虚拟机都没有选用引用计数算法来管理内存。</li></ul><h5 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h5><p>这个算法的思路就是通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象时不可用的。</p><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h4 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h4><h4 id="3-如何回收？"><a href="#3-如何回收？" class="headerlink" title="3. 如何回收？"></a>3. 如何回收？</h4><h3 id="4-内存调优"><a href="#4-内存调优" class="headerlink" title="4. 内存调优"></a>4. 内存调优</h3><p><strong>调优目的：</strong>减少GC的频率尤其是<code>Full GC</code>的次数，过多的GC会占用很多系统资源影响吞吐量。特别要关注Full GC，因为它会对整个堆进行整理。</p><p><strong>主要手段：</strong>JVM调优主要通过配置JVM的参数来提高垃圾回收的速度，合理分配堆内存各部分的比例。</p><p><strong>导致Full GC的几种情况和调优策略：</strong></p><ul><li>旧生代空间不足<br>调优时<strong>尽量让对象在新生代GC时被回收</strong>、让对象在新生代多存活一段时间和<strong>不要创建过大的对象及数组</strong>避免直接在旧生代创建对象 </li><li>持久代（<code>Pemanet Generation</code>）空间不足<br>增大<code>Perm Gen</code>空间，<strong>避免太多静态对象</strong> </li><li>统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间<br><strong>控制好新生代和旧生代的比例</strong> </li><li><code>System.gc()</code>被显示调用<br>垃圾回收不要手动触发，尽量依靠JVM自身的机制 </li></ul><p>堆内存比例不良设置会导致什么后果：</p><p>1）新生代设置过小</p><p>一是新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发<code>Full GC</code></p><p>2）新生代设置过大</p><p>一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发<code>Full GC</code>；二是新生代GC耗时大幅度增加</p><p><strong>一般说来新生代占整个堆1/3比较合适</strong></p><p>3）Survivor设置过小</p><p>导致对象从eden直接到达旧生代，降低了在新生代的存活时间</p><p>4）Survivor设置过大</p><p>导致eden过小，增加了GC频率</p><p>另外，通过<code>-XX:MaxTenuringThreshold=n</code>来控制新生代存活时间，尽量让对象在新生代被回收</p><p>JVM提供两种较为简单的<strong>GC策略</strong>的设置方式：</p><p>1）吞吐量优先</p><p>JVM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由<code>-XX:GCTimeRatio=n</code>来设置</p><p>2）暂停时间优先</p><p>JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由<code>-XX:MaxGCPauseRatio=n</code>来设置</p><p><strong>JVM常见配置</strong></p><ol><li>堆设置<ul><li>-Xms:初始堆大小</li><li>-Xmx:最大堆大小</li><li>-XX:NewSize=n:设置年轻代大小</li><li>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li><li>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3:2，一个Survivor区占整个年轻代的1/5</li><li>-XX:MaxPermSize=n:设置持久代大小</li></ul></li><li>收集器设置<ul><li>-XX:+UseSerialGC:设置串行收集器</li><li>-XX:+UseParallelGC:设置并行收集器</li><li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC:设置并发收集器</li></ul></li><li>垃圾回收统计信息<ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul></li><li>并行收集器设置<ul><li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li><li>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</li><li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li></ul></li><li>并发收集器设置<ul><li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li><li>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li></ul></li></ol><h3 id="JVM常见面试题"><a href="#JVM常见面试题" class="headerlink" title="JVM常见面试题"></a>JVM常见面试题</h3><h4 id="深入理解虚拟机之Java内存区域"><a href="#深入理解虚拟机之Java内存区域" class="headerlink" title="深入理解虚拟机之Java内存区域"></a>深入理解虚拟机之Java内存区域</h4><ol><li>介绍下Java内存区域（运行时数据区）。</li><li>对象的访问定位的两种方式。</li></ol><h4 id="深入理解虚拟机之垃圾回收"><a href="#深入理解虚拟机之垃圾回收" class="headerlink" title="深入理解虚拟机之垃圾回收"></a>深入理解虚拟机之垃圾回收</h4><ol><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有那些？</li><li>介绍一下CMS,G1收集器。</li><li>Minor GC和Full GC 有什么不同呢？</li></ol><h4 id="虚拟机性能监控和故障处理工具"><a href="#虚拟机性能监控和故障处理工具" class="headerlink" title="虚拟机性能监控和故障处理工具"></a>虚拟机性能监控和故障处理工具</h4><ol><li>JVM调优的常见命令行工具有哪些？</li></ol><h4 id="深入理解虚拟机之类文件结构"><a href="#深入理解虚拟机之类文件结构" class="headerlink" title="深入理解虚拟机之类文件结构"></a>深入理解虚拟机之类文件结构</h4><ol><li>简单介绍一下Class类文件结构（常量池主要存放的是那两大常量？Class文件的继承关系是如何确定的？字段表、方法表、属性表主要包含那些信息？）</li></ol><h4 id="深入理解虚拟机之类加载机制"><a href="#深入理解虚拟机之类加载机制" class="headerlink" title="深入理解虚拟机之类加载机制"></a>深入理解虚拟机之类加载机制</h4><ol><li>简单说说类加载过程，里面执行了哪些操作？</li><li>对类加载器有了解吗？</li><li>什么是双亲委派模型？</li><li>双亲委派模型的工作过程以及使用它的好处。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装maven</title>
      <link href="/Maven/"/>
      <url>/Maven/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux安装maven"><a href="#Linux安装maven" class="headerlink" title="Linux安装maven"></a>Linux安装maven</h2><a id="more"></a><ol><li><p>将tar包解压</p><p><code>tar -zxvf appache-maven-3.5.2-bin.tar.gz</code></p></li><li><p>配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>打开环境变量配置文件</span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>新增MAVEN_HOME，等于号后边是maven解压的文件夹地址</span><br><span class="line">export MAVEN_HOME=/usr/local/maven/apache-maven-3.5.2</span><br><span class="line"><span class="meta">#</span>找到PATH行，追加$MAVEN_HOME/bin</span><br><span class="line"><span class="meta">#</span>例如：</span><br><span class="line">PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>重新刷新配置文件</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>测试安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -version</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 类别1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ开放消息</title>
      <link href="/RocketMQ/10.%E5%BC%80%E6%94%BE%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/"/>
      <url>/RocketMQ/10.%E5%BC%80%E6%94%BE%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="开放消息"><a href="#开放消息" class="headerlink" title="开放消息"></a>开放消息</h1><p>开放消息，其中包括建立行业指南和消息传递，流式传输规范，从而为金融，电子商务，物联网和大数据领域提供通用框架。 在分布式异构环境中，设计原则是面向云，简单，灵活和独立于语言。 符合这些规范将使跨所有主要平台和操作系统开发异构消息应用程序成为可能。</p><a id="more"></a><p> <code>RocketMQ</code>提供了<code>OpenMessaging 0.1.0-alpha</code>的部分实现，以下示例演示了如何基于<code>OpenMessaging</code>访问<code>RocketMQ</code>。 </p><h4 id="OMSProducer"><a href="#OMSProducer" class="headerlink" title="OMSProducer"></a>OMSProducer</h4><p> 以下示例显示了如何以同步，异步或单向传输方式将消息发送到RocketMQ代理。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OMSProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MessagingAccessPoint messagingAccessPoint = MessagingAccessPointFactory</span><br><span class="line">            .getMessagingAccessPoint(<span class="string">"openmessaging:rocketmq://IP1:9876,IP2:9876/namespace"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Producer producer = messagingAccessPoint.createProducer();</span><br><span class="line"></span><br><span class="line">        messagingAccessPoint.startup();</span><br><span class="line">        System.out.printf(<span class="string">"MessagingAccessPoint startup OK%n"</span>);</span><br><span class="line"></span><br><span class="line">        producer.startup();</span><br><span class="line">        System.out.printf(<span class="string">"Producer startup OK%n"</span>);</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            Message message = producer.createBytesMessageToTopic(<span class="string">"OMS_HELLO_TOPIC"</span>, <span class="string">"OMS_HELLO_BODY"</span>.getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">            SendResult sendResult = producer.send(message);</span><br><span class="line">            System.out.printf(<span class="string">"Send sync message OK, msgId: %s%n"</span>, sendResult.messageId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">final</span> Promise&lt;SendResult&gt; result = producer.sendAsync(producer.createBytesMessageToTopic(<span class="string">"OMS_HELLO_TOPIC"</span>, <span class="string">"OMS_HELLO_BODY"</span>.getBytes(Charset.forName(<span class="string">"UTF-8"</span>))));</span><br><span class="line">            result.addListener(<span class="keyword">new</span> PromiseListener&lt;SendResult&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationCompleted</span><span class="params">(Promise&lt;SendResult&gt; promise)</span> </span>&#123;</span><br><span class="line">                    System.out.printf(<span class="string">"Send async message OK, msgId: %s%n"</span>, promise.get().messageId());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationFailed</span><span class="params">(Promise&lt;SendResult&gt; promise)</span> </span>&#123;</span><br><span class="line">                    System.out.printf(<span class="string">"Send async message Failed, error: %s%n"</span>, promise.getThrowable().getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            producer.sendOneway(producer.createBytesMessageToTopic(<span class="string">"OMS_HELLO_TOPIC"</span>, <span class="string">"OMS_HELLO_BODY"</span>.getBytes(Charset.forName(<span class="string">"UTF-8"</span>))));</span><br><span class="line">            System.out.printf(<span class="string">"Send oneway message OK%n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">        messagingAccessPoint.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OMSPullConsumer"><a href="#OMSPullConsumer" class="headerlink" title="OMSPullConsumer"></a>OMSPullConsumer</h4><p> 使用OMS PullConsumer轮询来自指定队列的消息。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OMSPullConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MessagingAccessPoint messagingAccessPoint = MessagingAccessPointFactory</span><br><span class="line">            .getMessagingAccessPoint(<span class="string">"openmessaging:rocketmq://IP1:9876,IP2:9876/namespace"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PullConsumer consumer = messagingAccessPoint.createPullConsumer(<span class="string">"OMS_HELLO_TOPIC"</span>,</span><br><span class="line">            OMS.newKeyValue().put(NonStandardKeys.CONSUMER_GROUP, <span class="string">"OMS_CONSUMER"</span>));</span><br><span class="line"></span><br><span class="line">        messagingAccessPoint.startup();</span><br><span class="line">        System.out.printf(<span class="string">"MessagingAccessPoint startup OK%n"</span>);</span><br><span class="line">        </span><br><span class="line">        consumer.startup();</span><br><span class="line">        System.out.printf(<span class="string">"Consumer startup OK%n"</span>);</span><br><span class="line"></span><br><span class="line">        Message message = consumer.poll();</span><br><span class="line">        <span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msgId = message.headers().getString(MessageHeader.MESSAGE_ID);</span><br><span class="line">            System.out.printf(<span class="string">"Received one message: %s%n"</span>, msgId);</span><br><span class="line">            consumer.ack(msgId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumer.shutdown();</span><br><span class="line">        messagingAccessPoint.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OMSPushConsumer"><a href="#OMSPushConsumer" class="headerlink" title="OMSPushConsumer"></a>OMSPushConsumer</h4><p> 将<code>OMS PushConsumer</code>附加到指定的队列，并通过<code>MessageListener</code>消费消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OMSPushConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MessagingAccessPoint messagingAccessPoint = MessagingAccessPointFactory</span><br><span class="line">            .getMessagingAccessPoint(<span class="string">"openmessaging:rocketmq://IP1:9876,IP2:9876/namespace"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PushConsumer consumer = messagingAccessPoint.</span><br><span class="line">            createPushConsumer(OMS.newKeyValue().put(NonStandardKeys.CONSUMER_GROUP, <span class="string">"OMS_CONSUMER"</span>));</span><br><span class="line"></span><br><span class="line">        messagingAccessPoint.startup();</span><br><span class="line">        System.out.printf(<span class="string">"MessagingAccessPoint startup OK%n"</span>);</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                consumer.shutdown();</span><br><span class="line">                messagingAccessPoint.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        </span><br><span class="line">        consumer.attachQueue(<span class="string">"OMS_HELLO_TOPIC"</span>, <span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">final</span> Message message, <span class="keyword">final</span> ReceivedMessageContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"Received one message: %s%n"</span>, message.headers().getString(MessageHeader.MESSAGE_ID));</span><br><span class="line">                context.ack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要使用RocketMQ</title>
      <link href="/RocketMQ/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8RocketMQ/"/>
      <url>/RocketMQ/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8RocketMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>​    早些时候，我们基于<code>ActiveMQ5.x(大于5.3)</code>去构建分布式消息中间件，我们在多种业务之间使用它进行异步通讯，比如搜索，社交网络活动流，数据管道流，甚至用它来处理交易流程。随着我们订单业务的增长， 来自我们的消息集群的压力也变得越来越大。 </p><a id="more"></a><h1 id="为什么选择RocketMQ？"><a href="#为什么选择RocketMQ？" class="headerlink" title="为什么选择RocketMQ？"></a>为什么选择RocketMQ？</h1><p>​    我们发现，随着队列数量和虚拟<code>Topic</code>数量的增加，<code>ActiveMQ</code>的<code>IO</code>模块会到达一个瓶颈，我们尝试通过节流、断路或降级去解决这个问题，但是效果并不是很好。所以我们开始关注当时比较流行的消息解决方案：<code>Kafka</code>。不幸的是，<code>Kafka</code>并不能满足我们的需求，尤其是在低延迟和高可靠性方面。 点击<a href="http://rocketmq.apache.org/rocketmq/how-to-support-more-queues-in-rocketmq/" target="_blank" rel="noopener">这里</a> 查看详情。</p><p>​    基于以上情况，我们决定自己开发一个新的消息引擎来应对更广泛的应用场景，包括从传统的订阅发布到海量实时零丢失的交易系统。 我们认为这个解决方案是对大家有用的，因此我们希望向社区开放它。  如今，超过100家公司在其业务中使用了RocketMQ的开源版本。</p><p> 下表展示了<code>RocketMQ</code>、<code>ActiveMQ</code>和<code>Kafka</code>( <a href="https://github.com/akullpp/awesome-java" target="_blank" rel="noopener">awesome-java</a> 榜单中的<code>Apache</code>最受欢迎的消息解决方案)之间的比较 </p><h1 id="RocketMQ-vs-ActiveMQ-vs-Kafka"><a href="#RocketMQ-vs-ActiveMQ-vs-Kafka" class="headerlink" title="RocketMQ vs. ActiveMQ vs. Kafka"></a>RocketMQ vs. ActiveMQ vs. Kafka</h1><p>​    请注意，本文档由RocketMQ团队编写。尽管理想的情况是对技术和功能进行无私的比较，但作者的专业知识和偏见显然会偏向RocketMQ。</p><p> 下表是一目了然的快速参考，可快速发现RocketMQ及其最受欢迎的替代产品之间的差异</p><table><thead><tr><th align="left">Messaging Product</th><th align="left">Client SDK</th><th align="left">Protocol and Specification</th><th align="left">Ordered Message</th><th align="left">Scheduled Message</th><th align="left">Batched Message</th><th align="left">BroadCast Message</th><th align="left">Message Filter</th><th align="left">Server Triggered Redelivery</th><th align="left">Message Storage</th><th align="left">Message Retroactive</th><th align="left">Message Priority</th><th align="left">High Availability and Failover</th><th align="left">Message Track</th><th align="left">Configuration</th><th align="left">Management and Operation Tools</th></tr></thead><tbody><tr><td align="left">ActiveMQ</td><td align="left">Java, .NET, C++ etc.</td><td align="left">Push model, support OpenWire, STOMP, AMQP, MQTT, JMS</td><td align="left">Exclusive Consumer or Exclusive Queues can ensure ordering</td><td align="left">Supported</td><td align="left">Not Supported</td><td align="left">Supported</td><td align="left">Supported</td><td align="left">Not Supported</td><td align="left">Supports very fast persistence using JDBC along with a high performance journal，such as levelDB, kahaDB</td><td align="left">Supported</td><td align="left">Supported</td><td align="left">Supported, depending on storage,if using kahadb it requires a ZooKeeper server</td><td align="left">Not Supported</td><td align="left">The default configuration is low level, user need to optimize the configuration parameters</td><td align="left">Supported</td></tr><tr><td align="left">Kafka</td><td align="left">Java, Scala etc.</td><td align="left">Pull model, support TCP</td><td align="left">Ensure ordering of messages within a partition</td><td align="left">Not Supported</td><td align="left">Supported, with async producer</td><td align="left">Not Supported</td><td align="left">Supported, you can use Kafka Streams to filter messages</td><td align="left">Not Supported</td><td align="left">High performance file storage</td><td align="left">Supported offset indicate</td><td align="left">Not Supported</td><td align="left">Supported, requires a ZooKeeper server</td><td align="left">Not Supported</td><td align="left">Kafka uses key-value pairs format for configuration. These values can be supplied either from a file or programmatically.</td><td align="left">Supported, use terminal command to expose core metrics</td></tr><tr><td align="left">RocketMQ</td><td align="left">Java, C++, Go</td><td align="left">Pull model, support TCP, JMS, OpenMessaging</td><td align="left">Ensure strict ordering of messages,and can scale out gracefully</td><td align="left">Supported</td><td align="left">Supported, with sync mode to avoid message loss</td><td align="left">Supported</td><td align="left">Supported, property filter expressions based on SQL92</td><td align="left">Supported</td><td align="left">High performance and low latency file storage</td><td align="left">Supported timestamp and offset two indicates</td><td align="left">Not Supported</td><td align="left">Supported, Master-Slave model, without another kit</td><td align="left">Supported</td><td align="left">Work out of box,user only need to pay attention to a few configurations</td><td align="left">Supported, rich web and terminal command to expose core metrics</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ事务消息</title>
      <link href="/RocketMQ/11.%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/"/>
      <url>/RocketMQ/11.%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="事务消息示例"><a href="#事务消息示例" class="headerlink" title="事务消息示例"></a>事务消息示例</h1><h3 id="什么是事务消息"><a href="#什么是事务消息" class="headerlink" title="什么是事务消息?"></a>什么是事务消息?</h3><p>可以将其视为两阶段提交消息实现，以确保分布式系统中的最终一致性。 事务性消息可确保本地事务的执行和消息的发送可以原子方式执行。</p><a id="more"></a><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ol><li>事务消息不支持定时消息和批量消息；</li><li>为了避免对单个消息进行过多的检查并导致半个队列的消息积累，我们默认将单个消息的检查数量限制为15次，但是用户可以通过更改<code>broker</code>配置中的“ <code>transactionCheckMax</code>”参数来更改此限制 ，如果一条消息经过“ <code>transactionCheckMax</code>”次检查，默认情况下，<code>broker</code>将丢弃此消息并同时打印错误日志。 用户可以通过重写“ <code>AbstractTransactionCheckListener</code>”类来更改此行为。</li><li>事务性消息会在一定时间后（由代理配置中的参数“ <code>transactionTimeout</code>”决定）被确认。 用户还可以在发送事务性消息时通过设置用户属性“ <code>CHECK_IMMUNITY_TIME_IN_SECONDS</code>”来更改此限制，该参数优先于“ <code>transactionMsgTimeout</code>”参数。</li><li>事务性消息可能被检查或消费了不止一次 。</li><li>已经提交的消息重复提交给用户目标<code>topic</code>可能会失败，目前版本取决于日志记录。<code>RocketMQ</code>本身的高可用性机制可确保高可用性。 如果您想确保交易消息不会丢失并且确保交易的完整性，建议使用同步重复写入机制.</li><li>事务消息生产者的ID不能和其他类型的消息共享。与其他类型的消息不一样的是，事务消息允许向后查询。<code>MQ Server</code>通过生产者ID查询客户机。</li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li><p>事务状态</p><p>事务消息有三种状态：</p><ol><li><code>TransactionStatus.CommitTransaction</code>: 提交事务，这意味着允许消费者使用此消息 </li><li><code>TransactionStatus.RollbackTransaction</code>: 回滚事务，这意味着该消息将被删除并且不允许使用 </li><li><code>TransactionStatus.Unknown</code>: 中间状态，这意味着需要MQ进行check back以确定状态 </li></ol></li><li><p>发送事务消息</p><ol><li><p>创建TransactionalProducer，事务消息生产者</p><p>使用<code>TransactionMQProducer</code>类创建生产者客户端，并指定唯一的<code>producerGroup</code>，然后可以设置自定义线程池来处理检查请求。 执行本地事务后，需要根据执行结果对MQ进行回复，回复状态如上节所述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                thread.setName(<span class="string">"client-transaction-msg-check-thread"</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[] &#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>, <span class="string">"TagE"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg =</span><br><span class="line">                    <span class="keyword">new</span> Message(<span class="string">"TopicTest1234"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i,</span><br><span class="line">                        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>TransactionListener</code>接口 </p><p>“ <code>executeLocalTransaction</code>”方法用于执行本地事务。 当消息发送成功一半的时候，它返回上一节中提到的三个事务状态之一。</p><p>“ <code>checkLocalTransaction</code>”方法用于检查本地事务状态并响应MQ检查请求。 它还返回上一部分中提到的三个事务状态之一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> AtomicInteger transactionIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> value = transactionIndex.getAndIncrement();</span><br><span class="line">           <span class="keyword">int</span> status = value % <span class="number">3</span>;</span><br><span class="line">           localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">           <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">           Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != status) &#123;</span><br><span class="line">               <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">                   <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                       <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                   <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                       <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                   <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                       <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ核心概念解释</title>
      <link href="/RocketMQ/12.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A/"/>
      <url>/RocketMQ/12.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><a id="more"></a><p> <img src="../assets/rmq-model.png" alt="RocketMQ model"> </p><p> 根据上述模型，我们可以更深入地研究有关消息传递系统设计的一些主题。 </p><ul><li>消费者并发</li><li>消费者热点 </li><li>消费者负载平衡 </li><li>消息路由</li><li>连接复用 </li><li>金丝雀部署 </li></ul><h1 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h1><p> 生产者将业务应用程序系统生成的消息发送给代理（<code>broker</code>）。 <code>RocketMQ</code>提供了多种发送范例：同步，异步和单向.</p><h2 id="Producer-Group"><a href="#Producer-Group" class="headerlink" title="Producer Group"></a>Producer Group</h2><p> 具有相同角色的生产者被分组在一起。如果原始生产者在事务发生后崩溃，则<code>Broker</code>可以联系同一生产者组的不同生产者实例以进行提交或回退事务。</p><p> <strong>警告</strong>： 考虑到生产者在发送消息方面足够强大，每个生产者组仅允许一个实例，以避免不必要的生产者实例初始化 。</p><h2 id="PullConsumer"><a href="#PullConsumer" class="headerlink" title="PullConsumer"></a>PullConsumer</h2><p> <code>pull consumer</code>主动从<code>Brokers</code>那里拉消息。一旦提取了一批消息，用户应用程序就会启动消费过程 。</p><h2 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h2><p> <code>Push consumer</code>将消息拉取、消耗进度和维护其他工作封装在内，将回调接口留给最终用户来实现，该接口将在消息到达时执行。 </p><h2 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h2><p> 与前面提到的生产者组相似，角色完全相同的消费者被分组在一起并命名为“消费者组” 。</p><p> 消费者组是一个很棒的概念，通过它，可以很容易地在消息消耗方面实现负载平衡和容错的目标。</p><p><strong>警告：</strong>  <code>Consumer Group</code>的<code>consumer</code>实例必须具有完全相同的主题订阅 .</p><h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><p>主题是<code>producer</code>传递消息和<code>consumer</code>提取消息的类别。 <code>topic</code>与生产者和消费者之间的关系非常松散。 具体来说，一个主题可能有零个，一个或多个向其发送消息的生产者。 相反，生产者可以发送不同主题的消息。 从消费者的角度来看，一个主题可以由零个，一个或多个消费者组订阅。 与此类似，消费者组可以订阅一个或多个主题，只要该组的实例保持其订阅一致即可。</p><h1 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h1><p><code>message</code>是要传递的消息。 <code>Message</code>中必须包含一个主题，该主题可以解释为要发送给您的信的地址。 消息还可能具有可选标签和额外的键值对。 例如，您可以为消息设置业务密钥，并在代理服务器上查找消息以在开发过程中诊断问题.</p><h2 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h2><p> 主题(<code>topic</code>)分为一个或多个子主题(<code>sub-topic</code>)，即“消息队列” </p><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>标签也就是子主题(<code>sub-topic</code>)，为用户提供了额外的灵活性。 使用标签，来自使同一业务模块的目的不同的消息具有相同的主题和不同的标签。 标签将有助于保持代码整洁和一致，标签还可以简化<code>RocketMQ</code>提供的查询系统。</p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p><code>Broker</code>是<code>RocketMQ</code>系统的主要组成部分。 它接收生产者(<code>producer</code>)发送过来的消息，进行存储并准备处理消费者的拉取消息请求。 它还存储与消息相关的元数据，包括使用者组，使用者进度偏移量和主题/队列信息。</p><h1 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h1><p><code>Name Server</code>充当路由信息提供者。生产者/消费者客户端通过查找主题来查找相应的<code>Broker</code>列表。 </p><h1 id="Message-Model"><a href="#Message-Model" class="headerlink" title="Message Model"></a>Message Model</h1><ul><li>Clustering</li><li>Broadcasting</li></ul>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ快速开始</title>
      <link href="/RocketMQ/2.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
      <url>/RocketMQ/2.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p> 本快速入门指南详细说明了如何在本地计算机上安装<code>RocketMQ</code>消息传递系统以发送和接收消息。 </p><a id="more"></a><h1 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h1><p> 假定在安装<code>RocketMQ</code>之前您已安装以下软件： </p><ol><li>64位操作系统, 推荐使用Linux/Unix/Mac ;</li><li>64bit JDK 1.8+;</li><li>Maven 3.2.x;</li><li>Git;</li><li>Broker server机器4G以上的磁盘空间</li></ol><h1 id="安装-amp-构建"><a href="#安装-amp-构建" class="headerlink" title="安装&amp;构建"></a>安装&amp;构建</h1><p> 点击<a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.4.0/rocketmq-all-4.4.0-source-release.zip" target="_blank" rel="noopener">这里</a> 下载 4.4.0 版本的源码发行包. 也可以点击 <a href="http://rocketmq.apache.org/release_notes/release-notes-4.4.0/" target="_blank" rel="noopener">这里</a>下载发行版二进制包.</p><p> 现在执行以下命令以解压4.4.0源代码发行包并构建二进制工件。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; unzip rocketmq-all-4.4.0-source-release.zip</span><br><span class="line">&gt; <span class="built_in">cd</span> rocketmq-all-4.4.0/</span><br><span class="line">&gt; mvn -Prelease-all -DskipTests clean install -U</span><br><span class="line">&gt; <span class="built_in">cd</span> distribution/target/apache-rocketmq</span><br></pre></td></tr></table></figure><h1 id="启动Name-Server"><a href="#启动Name-Server" class="headerlink" title="启动Name Server"></a>启动Name Server</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqnamesrv &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure><h1 id="启动Broker"><a href="#启动Broker" class="headerlink" title="启动Broker"></a>启动Broker</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/broker.log </span><br><span class="line">The broker[%s, 172.30.30.233:10911] boot success...</span><br></pre></td></tr></table></figure><h1 id="发送、接收测试消息"><a href="#发送、接收测试消息" class="headerlink" title="发送、接收测试消息"></a>发送、接收测试消息</h1><p> 在发送/接收消息之前，我们需要告诉客户端<code>NameServer</code>的位置。  <code>RocketMQ</code>提供了多种方法来实现，简单地我们可以设置一个环境变量<code>NAMESRV_ADDR</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId= ...</span><br><span class="line"></span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br><span class="line">ConsumeMessageThread_%d Receive New Messages: [MessageExt...</span><br></pre></td></tr></table></figure><h1 id="关闭服务端"><a href="#关闭服务端" class="headerlink" title="关闭服务端"></a>关闭服务端</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId= ...</span><br><span class="line"></span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br><span class="line">ConsumeMessageThread_%d Receive New Messages: [MessageExt...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ有序消息</title>
      <link href="/RocketMQ/4.%E6%9C%89%E5%BA%8F%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/"/>
      <url>/RocketMQ/4.%E6%9C%89%E5%BA%8F%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="有序消息"><a href="#有序消息" class="headerlink" title="有序消息"></a>有序消息</h1><p><code>RocketMQ</code>使用先进先出的方式提供有序消息模式。</p><p> 下面的示例演示了全局和分区有序消息的发送/接收。 </p><a id="more"></a><h4 id="消息发送的代码例子"><a href="#消息发送的代码例子" class="headerlink" title="消息发送的代码例子"></a>消息发送的代码例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        MQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"example_group_name"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[] &#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>, <span class="string">"TagE"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> orderId = i % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTestjjj"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i,</span><br><span class="line">                    (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                Integer id = (Integer) arg;</span><br><span class="line">                <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;, orderId);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//server shutdown</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="订阅消息示例代码"><a href="#订阅消息示例代码" class="headerlink" title="订阅消息示例代码"></a>订阅消息示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"example_group_name"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">            AtomicLong consumeTimes = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                context.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">                System.out.printf(Thread.currentThread().getName() + <span class="string">" Receive New Messages: "</span> + msgs + <span class="string">"%n"</span>);</span><br><span class="line">                <span class="keyword">this</span>.consumeTimes.incrementAndGet();</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.ROLLBACK;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.COMMIT;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    context.setSuspendCurrentQueueTimeMillis(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次性能优化的过程</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ简单示例</title>
      <link href="/RocketMQ/3.%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/RocketMQ/3.%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简单消息示例"><a href="#简单消息示例" class="headerlink" title="简单消息示例"></a>简单消息示例</h1><ul><li>使用<code>RocketMQ</code>以三种方式发送消息：<strong>可靠的同步发送</strong>，<strong>可靠的异步发送</strong>和<strong>单向传输</strong>。 </li><li>使用<code>RocketMQ</code>消费消息。</li></ul><a id="more"></a><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h4><p>maven:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> gradle: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'org.apache.rocketmq:rocketmq-client:4.3.0'</span></span><br></pre></td></tr></table></figure><h4 id="2-1-同步发送消息"><a href="#2-1-同步发送消息" class="headerlink" title="2.1 同步发送消息"></a>2.1 同步发送消息</h4><p> 可靠的同步发送方式主要应用在重要的通知消息，比如SMS通知，SMS营销系统等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-异步发送消息"><a href="#2-2-异步发送消息" class="headerlink" title="2.2 异步发送消息"></a>2.2 异步发送消息</h4><p> 异步传输通常用于对响应时间敏感的业务场景中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-单向传输消息"><a href="#2-3-单向传输消息" class="headerlink" title="2.3 单向传输消息"></a>2.3 单向传输消息</h4><p> 单向传输用于对消息可靠性要求不是特别高的情况，例如日志收集。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-消费消息"><a href="#3-消费消息" class="headerlink" title="3. 消费消息"></a>3. 消费消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instantiate with specified consumer group name.</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Subscribe one more more topics to consume.</span></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// Register callback to execute on arrival of messages fetched from brokers.</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Launch the consumer instance.</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-查找更多"><a href="#4-查找更多" class="headerlink" title="4. 查找更多"></a>4. 查找更多</h4><p> 或者，您可以从以下示例中获取更多示例：  <a href="https://github.com/apache/rocketmq/tree/master/example" target="_blank" rel="noopener">https://github.com/apache/rocketmq/tree/master/example</a> </p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ定时消息</title>
      <link href="/RocketMQ/6.%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/"/>
      <url>/RocketMQ/6.%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h1><h3 id="什么是定时消息？"><a href="#什么是定时消息？" class="headerlink" title="什么是定时消息？"></a>什么是定时消息？</h3><p>定时消息与普通消息的不同之处在于，它们要等到指定的时间后才能发送 。</p><a id="more"></a><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li><p>启动消费者以等待订阅的消息传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageConsumer</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Instantiate message consumer</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"ExampleConsumer"</span>);</span><br><span class="line">        <span class="comment">// Subscribe topics</span></span><br><span class="line">        consumer.subscribe(<span class="string">"TestTopic"</span>, <span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// Register message listener</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt message : messages) &#123;</span><br><span class="line">                    <span class="comment">// Print approximate delay time period</span></span><br><span class="line">                    System.out.println(<span class="string">"Receive message[msgId="</span> + message.getMsgId() + <span class="string">"] "</span></span><br><span class="line">                            + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="string">"ms later"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Launch consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发送定时消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageProducer</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Instantiate a producer to send scheduled messages</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">// Launch producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">int</span> totalMessagesToSend = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">"TestTopic"</span>, (<span class="string">"Hello scheduled message "</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// This message will be delivered to consumer 10 seconds later.</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// Send the message</span></span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// Shutdown producer after use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证</p><p> 您应该看到消息消费的时间比存储时间晚10秒。 </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ批量消息</title>
      <link href="/RocketMQ/7.%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/"/>
      <url>/RocketMQ/7.%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="批量消息示例"><a href="#批量消息示例" class="headerlink" title="批量消息示例"></a>批量消息示例</h1><h4 id="为什么要使用批量消息？"><a href="#为什么要使用批量消息？" class="headerlink" title="为什么要使用批量消息？"></a>为什么要使用批量消息？</h4><p> 批量发送消息可提高发送短消息的性能 </p><a id="more"></a><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p> 同一批次的消息应具有相同的<code>topic</code>，相同的<code>waitStoreMsgOK</code>，并且不支持定时消息。 </p><p> 此外，一个批次消息的总大小不得超过1MB。 </p><h4 id="怎样使用批量消息？"><a href="#怎样使用批量消息？" class="headerlink" title="怎样使用批量消息？"></a>怎样使用批量消息？</h4><p> 如果您一次只发送不超过1MB的消息，则可以轻松使用批处理： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String topic = <span class="string">"BatchTest"</span>;</span><br><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID001"</span>, <span class="string">"Hello world 0"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID002"</span>, <span class="string">"Hello world 1"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID003"</span>, <span class="string">"Hello world 2"</span>.getBytes()));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    producer.send(messages);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//handle the error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拆分成列表"><a href="#拆分成列表" class="headerlink" title="拆分成列表"></a>拆分成列表</h4><p> 仅当您发送大批量消息时，复杂性才会增加，并且您可能不确定它是否超过大小限制（1MiB） </p><p>这个时候，您最好拆分成列表： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSplitter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">List</span>&lt;<span class="title">Message</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_LIMIT = <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currIndex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> List&lt;Message&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex = currIndex;</span><br><span class="line">        <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            Message message = messages.get(nextIndex);</span><br><span class="line">            <span class="keyword">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class="line">            Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">            &#125;</span><br><span class="line">            tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">//for log overhead</span></span><br><span class="line">            <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="comment">//it is unexpected that single message exceeds the SIZE_LIMIT</span></span><br><span class="line">                <span class="comment">//here just let it go, otherwise it will block the splitting process</span></span><br><span class="line">                <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">//if the next sublist has no element, add this one and then break, otherwise just break</span></span><br><span class="line">                   nextIndex++;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalSize += tmpSize;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">        currIndex = nextIndex;</span><br><span class="line">        <span class="keyword">return</span> subList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//then you could split the large list into small ones:</span></span><br><span class="line">ListSplitter splitter = <span class="keyword">new</span> ListSplitter(messages);</span><br><span class="line"><span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       List&lt;Message&gt;  listItem = splitter.next();</span><br><span class="line">       producer.send(listItem);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">       <span class="comment">//handle the error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ日志输出</title>
      <link href="/RocketMQ/9.%E6%97%A5%E5%BF%97%E6%89%A9%E5%B1%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/RocketMQ/9.%E6%97%A5%E5%BF%97%E6%89%A9%E5%B1%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Logappender-示例"><a href="#Logappender-示例" class="headerlink" title="Logappender 示例"></a>Logappender 示例</h1><p><code>RocketMQ logappender</code>提供了<code>log4j</code>追加器，<code>log4j2</code>追加器和<code>logback</code>追加器以供使用，下面是配置示例。 </p><a id="more"></a><h4 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h4><p> 使用<code>log4j</code>属性配置文件时，请进行如下配置。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log4j.appender.mq=org.apache.rocketmq.logappender.log4j.RocketmqLog4jAppender</span><br><span class="line">log4j.appender.mq.Tag=yourTag</span><br><span class="line">log4j.appender.mq.Topic=yourLogTopic</span><br><span class="line">log4j.appender.mq.ProducerGroup=yourLogGroup</span><br><span class="line">log4j.appender.mq.NameServerAddress=yourRocketmqNameserverAddress</span><br><span class="line">log4j.appender.mq.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.mq.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-4r [%t] (%F:%L) %-5p - %m%n</span><br></pre></td></tr></table></figure><p> 使用<code>log4j</code> <code>xml</code>配置文件时，请按以下步骤进行配置，并添加一个异步<code>appender</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"mqAppender1"</span> <span class="attr">class</span>=<span class="string">"org.apache.rocketmq.logappender.log4j.RocketmqLog4jAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Tag"</span> <span class="attr">value</span>=<span class="string">"yourTag"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Topic"</span> <span class="attr">value</span>=<span class="string">"yourLogTopic"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ProducerGroup"</span> <span class="attr">value</span>=<span class="string">"yourLogGroup"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"NameServerAddress"</span> <span class="attr">value</span>=<span class="string">"yourRocketmqNameserverAddress"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss&#125;-%p %t %c - %m%n"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"mqAsyncAppender1"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.AsyncAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"BufferSize"</span> <span class="attr">value</span>=<span class="string">"1024"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Blocking"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"mqAppender1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h4><p> 使用<code>log4j2</code>时，请按以下步骤进行配置。如果不希望阻塞，只需为引用配置<code>asyncAppender</code>即可。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RocketMQ</span> <span class="attr">name</span>=<span class="string">"rocketmqAppender"</span> <span class="attr">producerGroup</span>=<span class="string">"yourLogGroup"</span> <span class="attr">nameServerAddress</span>=<span class="string">"yourRocketmqNameserverAddress"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">topic</span>=<span class="string">"yourLogTopic"</span> <span class="attr">tag</span>=<span class="string">"yourTag"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d [%p] hahahah %c %m%n"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RocketMQ</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h4><p> 使用<code>logback</code>时，还需要添加<code>asyncAppender</code>。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"mqAppender1"</span> <span class="attr">class</span>=<span class="string">"org.apache.rocketmq.logappender.logback.RocketmqLogbackAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag</span>&gt;</span>yourTag<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">topic</span>&gt;</span>yourLogTopic<span class="tag">&lt;/<span class="name">topic</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">producerGroup</span>&gt;</span>yourLogGroup<span class="tag">&lt;/<span class="name">producerGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nameServerAddress</span>&gt;</span>yourRocketmqNameserverAddress<span class="tag">&lt;/<span class="name">nameServerAddress</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%date %p %t - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"mqAsyncAppender1"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>80<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maxFlushTime</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">maxFlushTime</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">neverBlock</span>&gt;</span>true<span class="tag">&lt;/<span class="name">neverBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"mqAppender1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ消息过滤</title>
      <link href="/RocketMQ/8.%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E7%A4%BA%E4%BE%8B/"/>
      <url>/RocketMQ/8.%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="消息过滤示例"><a href="#消息过滤示例" class="headerlink" title="消息过滤示例"></a>消息过滤示例</h1><p> 在大多数情况下，<code>tag</code>是一种用于选择所需消息的简单实用的设计。例如 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"CID_EXAMPLE"</span>);</span><br><span class="line">consumer.subscribe(<span class="string">"TOPIC"</span>, <span class="string">"TAGA || TAGB || TAGC"</span>);</span><br></pre></td></tr></table></figure><p>消息消费者将收到包含<code>TAGA</code>或<code>TAGB</code>或<code>TAGC</code>的消息。但是限制是，一条消息只能有一个<code>tag</code>，这可能满足不了复杂的应用场景。在这种情况下，您可以使用<code>SQL</code>表达式来过滤出消息。 </p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p> <code>SQL</code>可以对发送消息时放入的属性进行一些计算。在<code>RocketMQ</code>定义的语法下，您可以实现一些有趣的逻辑。例如： </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|  a &gt; <span class="number">5</span> AND b = <span class="string">'abc'</span></span><br><span class="line">| a = <span class="number">10</span>   |  --------------------&gt; Gotten</span><br><span class="line">| b = <span class="string">'abc'</span>|</span><br><span class="line">| c = <span class="literal">true</span> |</span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|   a &gt; <span class="number">5</span> AND b = <span class="string">'abc'</span></span><br><span class="line">| a = <span class="number">1</span>    |  --------------------&gt; Missed</span><br><span class="line">| b = <span class="string">'abc'</span>|</span><br><span class="line">| c = <span class="literal">true</span> |</span><br><span class="line">------------</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p> <code>RocketMQ</code>仅定义了一些基本语法来支持此功能。您也可以轻松扩展它。 </p><ol><li>数值比较：比如<code>&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>BETWEEN</code>,<code>=</code>;</li><li>字符比较：比如<code>=</code>,<code>&lt;&gt;</code>,<code>IN</code>;</li><li><code>IS NULL</code>和<code>IS NOT NULL</code>;</li><li>逻辑比较：<code>AND</code>,<code>OR</code>,<code>NOT</code></li></ol><p>常量类型有：</p><ol><li>数值，比如：123,3.1415；</li><li>字符：比如<code>&#39;abc&#39;</code>,必须用单引号包裹；</li><li><code>NULL</code>,特殊常量</li><li>布尔型，<code>TRUE</code>,<code>FALSE</code></li></ol><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>只有<code>push</code>类消费者可以使用<code>SQL92</code>过滤消息，接口是：</p><p><code>public void subscribe(final String topic, final MessageSelector messageSelector)</code></p><h3 id="消息发送示例"><a href="#消息发送示例" class="headerlink" title="消息发送示例"></a>消息发送示例</h3><p> 发送消息时，可以通过<code>putUserProperty</code>方法将属性放在消息中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">    tag,</span><br><span class="line">    (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// Set some properties.</span></span><br><span class="line">msg.putUserProperty(<span class="string">"a"</span>, String.valueOf(i));</span><br><span class="line"></span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">   </span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure><h3 id="消费者示例"><a href="#消费者示例" class="headerlink" title="消费者示例"></a>消费者示例</h3><p> 使用时，使用<code>MessageSelector.bySql</code>通过<code>SQL92</code>选择消息。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// only subsribe messages have property a, also a &gt;=0 and a &lt;= 3</span></span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, MessageSelector.bySql(<span class="string">"a between 0 and 3"</span>);</span><br><span class="line"></span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/RocketMQ/RocketMQ/"/>
      <url>/RocketMQ/RocketMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是消息队列-MQ？"><a href="#什么是消息队列-MQ？" class="headerlink" title="什么是消息队列 MQ？"></a>什么是消息队列 MQ？</h1><p> 消息队列 MQ 既可为分布式应用系统提供异步解耦和削峰填谷的能力，同时也具备互联网应用所需的海量消息堆积、高吞吐、可靠重试等特性。 </p><a id="more"></a><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><strong>Topic</strong>：消息主题，一级消息类型，生产者向其发送消息。</li><li><strong>生产者</strong>：也称为消息发布者，负责生产并发送消息至 Topic。</li><li><strong>消费者</strong>：也称为消息订阅者，负责从 Topic 接收并消费消息。</li><li><strong>消息</strong>：生产者向 Topic 发送并最终传送给消费者的数据和（可选）属性的组合。</li><li><strong>消息属性</strong>：生产者可以为消息定义的属性，包含 Message Key 和 Tag。</li><li><strong>Group</strong>：一类生产者或消费者，这类生产者或消费者通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。</li></ul><h2 id="消息收发模型"><a href="#消息收发模型" class="headerlink" title="消息收发模型"></a>消息收发模型</h2><p>消息队列 MQ 支持发布/订阅模型，消息生产者应用创建 Topic 并将消息发送到 Topic。消费者应用创建对 Topic 的订阅以便从其接收消息。通信可以是一对多（扇出）、多对一（扇入）和多对多。</p><p> 具体通信如下图所示。 </p><p> <img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/29532/cn_zh/1568375976505/%E6%94%B6%E5%8F%91%E6%A8%A1%E5%9E%8B.PNG" alt="消息收发模型"> </p><ul><li><p>生产者集群: 用来表示发送消息应用，一个生产者集群下包含多个生产者实例，可以是多台机器，也可以是一台机器的多个进程，或者一个进程的多个生产者对象。</p><p>一个生产者集群可以发送多个 Topic 消息。发送分布式事务消息时，如果生产者中途意外宕机，Broker 会主动回调生产者集群的任意一台机器来确认事务状态。</p></li><li><p>消费者集群：用来表示消费消息应用，一个消费者集群下包含多个消费者实例，可以是多台机器，也可以是多个进程，或者是一个进程的多个消费者对象。</p><p>一个消费者集群下的多个消费者以均摊方式消费消息。如果设置的是广播方式，那么这个消费者集群下的每个实例都消费全量数据。</p><p> 一个消费者集群对应一个 Group ID，一个 Group ID 可以订阅多个 Topic，如图中的 Group 2 所示 .</p></li></ul><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p><strong>Topic</strong></p><p>消息主题，一级消息类型，通过 Topic 对消息进行分类。详情请参见 <a href="https://help.aliyun.com/document_detail/95837.html" target="_blank" rel="noopener">Topic 与 Tag 最佳实践</a>。</p><p><strong>Message</strong></p><p>消息，消息队列中信息传递的载体。</p><p><strong>Message ID</strong></p><p>消息的全局唯一标识，由消息队列 MQ 系统自动生成，唯一标识某条消息。</p><p><strong>Message Key</strong></p><p>消息的业务标识，由消息生产者（Producer）设置，唯一标识某个业务逻辑。</p><p><strong>Tag</strong></p><p>消息标签，二级消息类型，用来进一步区分某个 Topic 下的消息分类。详情请参见 <a href="https://help.aliyun.com/document_detail/95837.html" target="_blank" rel="noopener">Topic 与 Tag 最佳实践</a>。</p><p><strong>Producer</strong></p><p>消息生产者，也称为消息发布者，负责生产并发送消息。</p><p><strong>Producer 实例</strong></p><p>Producer 的一个对象实例，不同的 Producer 实例可以运行在不同进程内或者不同机器上。Producer 实例线程安全，可在同一进程内多线程之间共享。</p><p><strong>Consumer</strong></p><p>消息消费者，也称为消息订阅者，负责接收并消费消息。</p><p><strong>Consumer 实例</strong></p><p>Consumer 的一个对象实例，不同的 Consumer 实例可以运行在不同进程内或者不同机器上。一个 Consumer 实例内配置线程池消费消息。</p><p><strong>Group</strong></p><p>一类 Producer 或 Consumer，这类 Producer 或 Consumer 通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。</p><p><strong>Group ID</strong></p><p>Group 的标识。</p><p><strong>队列</strong></p><p>每个 Topic 下会由一到多个队列来存储消息。</p><p><strong>Exactly-Once 投递语义</strong></p><p>Exactly-Once 投递语义是指发送到消息系统的消息只能被 Consumer 处理且仅处理一次，即使 Consumer 重试消息发送导致某消息重复投递，该消息在 Consumer 也只被消费一次。</p><p><strong>集群消费</strong></p><p>一个 Group ID 所标识的所有 Consumer 平均分摊消费消息。例如某个 Topic 有 9 条消息，一个 Group ID 有 3 个 Consumer 实例，那么在集群消费模式下每个实例平均分摊，只消费其中的 3 条消息.</p><p><strong>广播消费</strong></p><p>一个 Group ID 所标识的所有 Consumer 都会各自消费某条消息一次。例如某个 Topic 有 9 条消息，一个 Group ID 有 3 个 Consumer 实例，那么在广播消费模式下每个实例都会各自消费 9 条消息。</p><p><strong>定时消息</strong></p><p>Producer 将消息发送到消息队列 MQ 服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费，该消息即定时消息。</p><p><strong>延时消息</strong></p><p>Producer 将消息发送到消息队列 MQ 服务端，但并不期望这条消息立马投递，而是延迟一定时间后才投递到 Consumer 进行消费，该消息即延时消息。</p><p><strong>事务消息</strong></p><p>消息队列 MQ 提供类似 X/Open XA 的分布事务功能，通过消息队列 MQ 的事务消息能达到分布式事务的最终一致。</p><p><strong>顺序消息</strong></p><p>消息队列 MQ 提供的一种按照顺序进行发布和消费的消息类型，分为全局顺序消息和分区顺序消息。</p><p><strong>全局顺序消息</strong></p><p>对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。</p><p><strong>分区顺序消息</strong></p><p>对于指定的一个 Topic，所有消息根据 Sharding Key 进行区块分区。同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding Key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Message Key 是完全不同的概念。</p><p><strong>消息堆积</strong></p><p>Producer 已经将消息发送到消息队列 MQ 的服务端，但由于 Consumer 消费能力有限，未能在短时间内将所有消息正确消费掉，此时在消息队列 MQ 的服务端保存着未被消费的消息，该状态即消息堆积。</p><p><strong>消息过滤</strong></p><p>Consumer 可以根据消息标签（Tag）对消息进行过滤，确保 Consumer 最终只接收被过滤后的消息类型。消息过滤在消息队列 MQ 的服务端完成</p><p><strong>消息轨迹</strong></p><p>在一条消息从 Producer 发出到 Consumer 消费处理过程中，由各个相关节点的时间、地点等数据汇聚而成的完整链路信息。通过消息轨迹，您能清晰定位消息从 Producer 发出，经由消息队列 MQ 服务端，投递给 Consumer 的完整链路，方便定位排查问题。</p><p><strong>重置消费位点</strong></p><p>以时间轴为坐标，在消息持久化存储的时间范围内（默认 3 天），重新设置 Consumer 对已订阅的 Topic 的消费进度，设置完成后 Consumer 将接收设定时间点之后由 Producer 发送到消息队列 MQ 服务端的消息。</p><p><strong>死信队列</strong></p><p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列 MQ 会自动进行<a href="https://help.aliyun.com/document_detail/43490.html" target="_blank" rel="noopener">消息重试</a>；达到最大重试次数后，若消费依然失败，则表明 Consumer 在正常情况下无法正确地消费该消息。此时，消息队列 MQ 不会立刻将消息丢弃，而是将这条消息发送到该 Consumer 对应的特殊队列中。</p><p>消息队列 MQ 将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p><strong>解压安装</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; unzip rocketmq-all-4.4.0-source-release.zip</span><br><span class="line">&gt; <span class="built_in">cd</span> rocketmq-all-4.4.0/</span><br><span class="line">&gt; mvn -Prelease-all -DskipTests clean install -U</span><br><span class="line">&gt; <span class="built_in">cd</span> distribution/target/apache-rocketmq</span><br></pre></td></tr></table></figure><p><strong>启动Name Server</strong></p><ol><li>启动nameserver<ol><li>./mqnamesrv</li><li>nohup ./mqnamesrv &gt; namesrv.out 2 &gt; &amp;1 &amp;</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqnamesrv &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure><p><strong>启动Broker</strong></p><ol><li>nohup sh mqbroker -n “localhost:9876” -c ../conf/2m-noslave/broker-a.properties &gt; broker.out &amp;</li><li>命令解释：-n “localhost:9876”表示指定当前broker归哪一台namesrv管理，nameserver默认监听端口时9876，-c …指定配置文件启动</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/broker.log </span><br><span class="line">The broker[%s, 172.30.30.233:10911] boot success...</span><br></pre></td></tr></table></figure><p>输入jps查看启动信息；./mqadmin clusterList=st -n localhost:9876  查看指定</p><p><strong>关闭服务端</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh bin/mqshutdown broker</span><br><span class="line">The mqbroker(36695) is running...</span><br><span class="line">Send shutdown request to mqbroker(36695) OK</span><br><span class="line"></span><br><span class="line">&gt; sh bin/mqshutdown namesrv</span><br><span class="line">The mqnamesrv(36664) is running...</span><br><span class="line">Send shutdown request to mqnamesrv(36664) OK</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要使用RocketMQ</title>
      <link href="/RocketMQ/5.%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/"/>
      <url>/RocketMQ/5.%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h1><h4 id="什么是广播？"><a href="#什么是广播？" class="headerlink" title="什么是广播？"></a>什么是广播？</h4><p> 广播是向所有订阅了某个<code>topic</code>的订阅者发送一条消息。如果希望所有订阅者都收到有关<code>topic</code>的消息，那么广播是一个不错的选择。</p><a id="more"></a><h4 id="生产者示例"><a href="#生产者示例" class="headerlink" title="生产者示例"></a>生产者示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ProducerGroupName"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                <span class="string">"TagA"</span>,</span><br><span class="line">                <span class="string">"OrderID188"</span>,</span><br><span class="line">                <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者示例"><a href="#消费者示例" class="headerlink" title="消费者示例"></a>消费者示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"example_group_name"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//set to broadcast mode</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(Thread.currentThread().getName() + <span class="string">" Receive New Messages: "</span> + msgs + <span class="string">"%n"</span>);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">"Broadcast Consumer Started.%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
